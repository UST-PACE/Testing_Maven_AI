pipeline {
    agent any

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        string(name: 'CUSTOM_TAG', defaultValue: '', description: 'Custom image tag override')
    }

    stages {

        stage('Dynamic Agent Selection') {
            agent {
                label {
                    label "${params.ENVIRONMENT == 'prod' ? 'docker-prod-capable' : 'docker-any'}"
                }
            }
            steps {
                script {
                    def nodeLabel = "${params.ENVIRONMENT == 'prod' ? 'PROD' : 'NON-PROD'}"
                    echo "Running on dynamic agent label: ${nodeLabel}"
                    sh 'echo "Dynamic agent selection successful"'
                }
            }
        }

        stage('Setup Environment') {
            steps {
                sh '''
                echo "Maven Version:"
                mvn -v
                echo "Docker Version:"
                docker --version
                echo "Environment: ${ENVIRONMENT}"
                '''
            }
        }

        stage('Complex Conditional Logic') {
            when {
                allOf {
                    not { environment name: 'ENVIRONMENT', value: 'prod' }
                    expression { params.CUSTOM_TAG == '' }
                }
            }
            steps {
                script {
                    // Complex Groovy logic that's hard to replicate in YAML
                    def buildVariant = (BUILD_NUMBER.toInteger() % 3 == 0) ? 'fast' : 
                                     (BUILD_NUMBER.toInteger() % 2 == 0) ? 'standard' : 'slow'
                    def parallelCount = buildVariant == 'fast' ? 4 : buildVariant == 'standard' ? 2 : 1
                    
                    echo "Build variant: ${buildVariant} with ${parallelCount} parallel branches"
                    writeFile file: 'variant.txt', text: "Variant: ${buildVariant}"
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'variant.txt', fingerprint: true
                }
            }
        }

        stage('Build Maven Project') {
            steps {
                sh 'mvn clean compile -DskipTests'
            }
        }

        stage('Package') {
            steps {
                sh 'mvn package -DskipTests'
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def tag = params.CUSTOM_TAG ?: "demo-app-${BUILD_NUMBER}-${ENVIRONMENT}"
                    sh "docker build -t ${tag} ."
                    env.IMAGE_TAG = tag
                }
            }
        }

        stage('Test Container (Smoke Check)') {
            steps {
                sh '''
                docker run -d -p 8081:8080 --name test-app ${IMAGE_TAG}
                echo "Waiting for application to start..."
                sleep 15
                echo "Skipping health check - assuming success"
                docker stop test-app || true
                docker rm test-app || true
                '''
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                docker stop demo-app || true
                docker rm demo-app || true
                docker run -d -p 8090:8080 --name demo-app ${IMAGE_TAG}
                echo "Jenkins pipeline completed successfully!"
                echo "App running at: http://localhost:8090"
                '''
            }
        }

        /* ----------------------------------------- ADVANCED JENKINS-ONLY FEATURES ----------------------------------------- */

        stage('Interactive Approval Gate') {
            steps {
                input message: 'Approve continuation to advanced stages?',
                     ok: 'Continue', 
                     submitterParameter: 'approver',
                     parameters: [
                         choice(name: 'ADVANCED_MODE', choices: ['lite', 'full', 'expert'], description: 'Complexity level')
                     ]
            }
            post {
                success {
                    echo "Approved by ${approver} in ${ADVANCED_MODE} mode"
                    script {
                        writeFile file: 'approval.txt', text: "Approved: ${approver} | Mode: ${ADVANCED_MODE}"
                    }
                }
            }
        }

        stage('Workspace Info (tool-free)') {
            steps {
                echo "Collecting workspace info and creating a tiny artifact..."
                sh '''
                  set -eu
                  echo "Date: $(date)"
                  echo "Node: $(hostname || echo unknown)"
                  echo "User: $(id -un || echo unknown)"
                  echo "Shell: ${SHELL:-/bin/sh}"
                  echo "Directory: $(pwd)"
                  echo "Contents:"
                  ls -la || true
                  mkdir -p demo
                  echo "Hello from build ${BUILD_NUMBER} (${ENVIRONMENT})" > demo/hello.txt
                  wc -c demo/hello.txt || true
                '''
                archiveArtifacts artifacts: 'demo/hello.txt', fingerprint: true, onlyIfSuccessful: true
            }
        }

        stage('Complex Nested Parallel Demo') {
            parallel {
                stage('Branch A - Multi-Level Parallel') {
                    parallel {
                        stage('A1 - Fast') {
                            steps {
                                sh '''
                                  set -eu
                                  echo "A1-Start ${BUILD_NUMBER}" > a1.txt
                                  sleep 0.5
                                  echo "A1-End" >> a1.txt
                                '''
                            }
                        }
                        stage('A2 - Slow') {
                            steps {
                                sh '''
                                  set -eu
                                  echo "A2-Start ${BUILD_NUMBER}" > a2.txt
                                  sleep 2
                                  echo "A2-End" >> a2.txt
                                '''
                            }
                        }
                    }
                }
                stage('Branch B') {
                    steps {
                        sh '''
                          set -eu
                          echo "B-Start ${BUILD_NUMBER}" > b.txt
                          sleep 1
                          echo "B-End" >> b.txt
                        '''
                    }
                }
                stage('Branch C - Dynamic') {
                    steps {
                        script {
                            def randomDelay = (1..3).find { it.toInteger() == (BUILD_NUMBER.toInteger() % 3) + 1 }
                            sh """
                              set -eu
                              echo "C-Start \${BUILD_NUMBER} (delay: ${randomDelay}s)" > c.txt
                              sleep ${randomDelay}
                              echo "C-End" >> c.txt
                            """
                        }
                    }
                }
            }
        }

        stage('Dynamic Milestone Management') {
            steps {
                script {
                    // Jenkins milestone - cancels previous runs if newer one starts
                    milestone(ordinal: BUILD_NUMBER.toInteger())
                    def statusFile = "milestone-${BUILD_NUMBER}.txt"
                    writeFile file: statusFile, text: "Milestone ${BUILD_NUMBER} reached at $(date)"
                    archiveArtifacts artifacts: "${statusFile}", fingerprint: true
                }
            }
        }

        stage('Collect Parallel Outputs') {
            steps {
                sh '''
                  set -eu
                  mkdir -p out
                  cat a1.txt a2.txt b.txt c.txt 2>/dev/null | true > out/combined.txt
                  echo "--- Combined ---"
                  cat out/combined.txt || true
                '''
                archiveArtifacts artifacts: 'out/combined.txt', fingerprint: true, onlyIfSuccessful: true
            }
        }

        stage('Advanced Retry / Timeout with Dynamic Logic') {
            steps {
                script {
                    // Dynamic timeout based on environment
                    def timeoutMinutes = params.ENVIRONMENT == 'prod' ? 5 : 2
                    timeout(time: timeoutMinutes, unit: 'MINUTES') {
                        retry(3) {
                            echo "Simulating complex flaky operation (attempt \${currentBuild.rawBuild.getExecutor().getNumberOfPreviousAttempts() + 1}/3)..."
                            sh '''
                              set -eu
                              FLAKE_CHANCE=30
                              if [ $((RANDOM % 100)) -lt $FLAKE_CHANCE ]; then
                                echo "Simulated failure (random: $RANDOM)"
                                exit 1
                              else
                                echo "Success on attempt $((currentBuild.rawBuild.getExecutor().getNumberOfPreviousAttempts() + 1))"
                              fi
                            '''
                        }
                    }
                }
            }
        }

        stage('Complex Stash / Unstash with Multiple Workspaces') {
            steps {
                sh '''
                  set -eu
                  mkdir -p stashdir1 stashdir2
                  echo "data1-${BUILD_NUMBER}" > stashdir1/data1.txt
                  echo "data2-${BUILD_NUMBER}" > stashdir2/data2.txt
                '''
                stash name: 'workspace1', includes: 'stashdir1/**'
                stash name: 'workspace2', includes: 'stashdir2/**'
                
                // Multiple workspace simulations
                dir('workspace-a') {
                    writeFile file: 'marker.txt', text: 'Workspace A'
                }
                deleteDir()
                
                dir('workspace-b') {
                    unstash 'workspace1'
                    sh 'cat stashdir1/data1.txt'
                }
                deleteDir()
                
                unstash 'workspace2'
                sh 'cat stashdir2/data2.txt'
                
                archiveArtifacts artifacts: 'stashdir*/*.txt', fingerprint: true
            }
        }

        stage('Stage-Specific Post Actions') {
            steps {
                sh '''
                  set -eu
                  mkdir -p stage-post
                  echo "Stage post demo - BUILD_NUMBER: ${BUILD_NUMBER}" > stage-post/demo.txt
                '''
            }
            post {
                success {
                    sh 'echo "STAGE SUCCESS: $(date)" >> stage-post/demo.txt'
                }
                failure {
                    sh 'echo "STAGE FAILURE: $(date)" >> stage-post/demo.txt'
                }
                always {
                    archiveArtifacts artifacts: 'stage-post/demo.txt', allowEmptyArchive: true
                }
            }
        }

        stage('Groovy-Driven Dynamic Generation') {
            steps {
                script {
                    // Pure Groovy logic - extremely difficult in GitHub Actions YAML
                    def artifacts = []
                    def buildInfo = [
                        buildNumber: BUILD_NUMBER,
                        environment: params.ENVIRONMENT,
                        timestamp: new Date(),
                        nodeName: env.NODE_NAME,
                        stagesCount: currentBuild.rawBuild.getExecution().getCurrentHeads().size()
                    ]
                    
                    writeFile file: 'groovy-report.json', text: groovy.json.JsonOutput.toJson(buildInfo)
                    archiveArtifacts artifacts: 'groovy-report.json', fingerprint: true
                    
                    // Dynamic parallel stage generation (Jenkins only)
                    def dynamicStages = [:]
                    (1..3).each { i ->
                        dynamicStages["Dynamic-${i}"] = {
                            sh "echo 'Dynamic stage ${i} executing on ${env.NODE_NAME}' > dynamic-${i}.txt"
                        }
                    }
                    parallel dynamicStages
                }
            }
        }

        stage('Summary Report') {
            steps {
                sh '''
                  set -eu
                  mkdir -p summary
                  {
                    echo "=== PIPELINE SUMMARY ==="
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Environment: ${ENVIRONMENT}"
                    echo "Image Tag: ${IMAGE_TAG:-not_set}"
                    echo "Date: $(date)"
                    echo "Node: $(hostname || echo unknown)"
                    echo "Advanced Mode: ${ADVANCED_MODE:-not_set}"
                    echo
                    echo "Workspace listing:"
                    ls -la
                    echo
                    find . -name "*.txt" -o -name "*.json" | while read file; do
                      [ -f "$file" ] && { echo "---- $file ----"; cat "$file"; echo; }
                    done
                  } > summary/complete-report.txt
                  echo "Complete report created: summary/complete-report.txt"
                '''
                archiveArtifacts artifacts: 'summary/complete-report.txt', fingerprint: true, onlyIfSuccessful: true
            }
        }
    }

    post {
        always {
            script {
                // Global cleanup with dynamic image tag
                sh '''
                docker stop demo-app test-app || true
                docker rm demo-app test-app || true
                docker rmi demo-app:* ${IMAGE_TAG:-demo-app:*} || true
                docker image prune -f || true
                '''
                
                // Final status report
                def finalStatus = currentBuild.result ?: 'UNKNOWN'
                echo "PIPELINE COMPLETED: ${finalStatus}"
            }
        }
        success {
            echo "üéâ Pipeline completed successfully!"
        }
        failure {
            echo "‚ùå Pipeline failed - check logs above"
        }
    }
}
